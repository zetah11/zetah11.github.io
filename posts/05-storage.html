<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name=viewport content="initial-scale=1, width=device-width">

    <title>Storage</title>

    <!-- KaTeX for pretty math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
          delimiters: [
            { left: '$$', right: '$$', display: true },
            { left: '$', right: '$', display: false },
          ],
        });
      });
    </script>

    <link rel=stylesheet href="../style.css">
  </head>

  <body>
    <article>
      <header>
        <h1>Storage</h1>
        
        <p>
          <time>2022 MAY 27</time>
          <span>LANG, Z</span>
        </p>
      </header>

      <!-- intro -------------------------------------------------------------->

      <p>
        Variables are somewhat vague creatures, so let's first define two
        separate terms:
      </p>

      <dl>
        <dt id="help">Name</dt>
        <dd>A variable name like <code>x</code>, <code>foo</code>, etc.</dd>

        <dt>Value</dt>
        <dd>The actual content of a variable</dd>
      </dl>

      <p>
        In this binding
      </p>

      <pre>
<h-k>let</h-k> fans: <h-t>Nat</h-t> = <h-l>5</h-l>
</pre>

      <p>
        we have a name <code>fans</code> and the value <code>5</code>. The name
        here is a kind of abstraction over the actual value (hence why we use
        the word <em>variable</em>). In a sense, it is a kind of compile-time
        reference to whatever chunk of memory the value itself occupies.
      </p>

      <p>
        Why compile time? Let's compare two C programs:
      </p>

      <div class="two">
        <pre>
<h-k>int</h-k> x;
x = <h-l>5</h-l>;
</pre>

        <pre>
<h-k>int</h-k> *y = malloc(<h-k>sizeof</h-k> *y);
*y = <h-l>5</h-l>;
</pre>
      </div>

      <p>
        The name <code>x</code> is a reference to the piece of memory in which
        we eventually put a <code>5</code>, while the name <code>y</code> is a
        reference to the piece of memory that contains
        <em>another reference</em> to the piece of memory in which the
        <code>5</code> is stored. If we look at the generated assembly, we won't
        see too much remarkable stuff:
      </p>

      <div class="two">
        <pre>
<h-k>push</h-k>    rbp
<h-k>mov</h-k>     rbp, rsp
<h-k>mov</h-k>     [rbp-<h-l>4</h-l>], <h-l>5</h-l>    <h-c># x = 5</h-c>
<h-k>pop</h-k>     rbp
<h-k>ret</h-k>
</pre>

        <pre>
<h-k>push</h-k>    rbp
<h-k>mov</h-k>     rbp, rsp
<h-k>mov</h-k>     edi, <h-l>4</h-l>
<h-k>call</h-k>    <h-t>malloc</h-t>      <h-c># rax = malloc(4)</h-c>
<h-k>mov</h-k>     [rax], <h-l>5</h-l>    <h-c># *y = 5</h-c>
<h-k>pop</h-k>     rbp
<h-k>ret</h-k>
</pre>
      </div>

      <p>
        The value we assign to <code>x</code> is stored at <code>rbp-4</code>,
        while the pointer we get from <code>malloc</code> is itself stored in
        <code>rax</code> (and might be put on the stack or even the heap in more
        complicated cases).
      </p>

      <p>
        This is a stark difference &ndash; notice that in
        <code>mov [rbp-4], 5</code> we know <em>ahead of time</em> where to put
        the value, while in <code>mov [rax], 5</code>, we don't yet know. In
        other words, the <em>name</em> <code>x</code> is a compile-time
        reference (equal to <code>rbp-4</code>). <code>y</code>, too, is a
        compile time reference, while the value it contains is a runtime
        reference. 
      </p>

      <p>
        This is even clearer if we move to mutable values:
      </p>

      <pre>
<h-k>var</h-k> x: <h-t>Nat</h-t> = <h-l>5</h-l>
<h-k>set</h-k> x = <h-l>10</h-l>
</pre>

      <p>
        Conceptually, the <code>10</code> that we put in <code>x</code> goes
        into the same chunk of memory in which the <code>5</code> was stored
        (effectively overwriting it). And though the compiler may choose to use
        complicated relative offsets, we always know where it is
        <em>at compile time</em>. It's as if we wrote
      </p>

      <pre>
*<h-l>7ffde4ba83ac</h-l> = <h-l>5</h-l>
*<h-l>7ffde4ba83ac</h-l> = <h-l>10</h-l>
</pre>

      <p>
        Because we have that information throughout compilation, we don't need
        to keep track of it anywhere at runtime &ndash; we can just put it in
        the appropriate places in the assembly, and be done with it. Compare
        that to the <code>malloc</code> example, where we <em>don't</em> have
        that information ahead of time, and therefore <em>do</em> need to keep
        track of it by storing it somewhere in memory. In the example assembly,
        that was just a register, but it can quickly become a stack allocated
        local variable, or a field in a heap allocated structure.
      </p>

      <p>
        The throughline here is the idea that
        <em>anywhere there's a variable, there's a reference</em>. It just so
        happens that we always need <em>some</em> reference that we know about
        at compile time in order to actually get anywhere, and the contents of a
        stack-allocated variable is a convenient place to start.
      </p>


      <!-- a different perspective -------------------------------------------->

      <h2>A different perspective</h2>

      <p>
        A variable is itself a container of some value. When I write
      </p>

      <pre><h-k>int</h-k> x = <h-l>5</h-l></pre>

      <p>
        Then I'm putting the value <code>5</code> <em>into</em> the variable
        <code>x</code>. Variables are mostly stack-allocated, which means that
        the variable itself resides on the stack. The statement above will
        thusly put some chunk of bits onto a predefined place on stack. And that
        place has a name &ndash; <code>x</code>.
      </p>

      <p>
        Allocating to the heap is no different. C itself has no concept of the
        heap, and so we have a variable <em>on the stack</em> which contains the
        dynamically generated name (the heap address), <em>through which</em> we
        can do heapy things.
      </p>

      <!-- allocators and storage --------------------------------------------->

      <h2>Allocators and storage</h2>

      <p>
        A type may specify what variables of that type look like. If we write
        something like
      </p>

      <pre>
<h-k>type</h-k> <h-t>Int</h-t> <h-k>in</h-k> <h-t>Int</h-t> = ... 
</pre>

      <p>
        Then we're saying that variables with the type <code>Int</code> store
        the numeric data in themselves. In other words, since local variables
        live on the call stack, that's where the number will live too.
      </p>

      <p>
        Contrast that with something like
      </p>

      <pre>
<h-k>type</h-k> <h-t>String</h-t> <h-k>in</h-k> <h-t>Heap</h-t> = ...
</pre>
  
      <p>
        Variables of the <code>String</code> store the actual text data on the
        heap, which means that the variable itself must contain an address.
      </p>

      <!-- notes -------------------------------------------------------------->

      <footer>
        <h2 id="notes">Notes</h2>

        <ol>
          <li>???</li>
        </ol>
      </footer>
    </article>
  </body>
</html>
