<!DOCTYPE html>Gd
<html>
  <head>
    <meta charset="utf-8">
    <meta name=viewport content="initial-scale=1, width=device-width">

    <title>Language features &amp; syntax sugar</title>

    <link rel=stylesheet href="../style.css">
  </head>

  <body>
    <article>
      <header>
        <h1>Language features &amp; syntax sugar</h1>
        
        <p>
          <time>2022 MAY 27</time>
          <span>LANG, Z</span>
        </p>
      </header>

      <!-- intro -------------------------------------------------------------->

      <p>
        As part of developing a new language, I have been attempting to entirely
        decouple the standard library from the compiler. The ultimate goal here
        is that the compiler treats the standard library just like any other
        package, which just happens to be auto-included in most programs by some
        higher-level build system.<sup><a href="#note-1" id="ref-1a">1</a></sup>
      </p>

      <p>
        This makes certain things like syntax sugar more difficult, since that
        has a tendency to couple the compiler (responsible for the desugaring)
        and the standard library (responsible for providing the necessary
        functionality). Consider the simple <code>for</code>-loop in Rust:
      </p>

      <pre>
<h-k>for</h-k> item <h-k>in</h-k> iter {
    frombulate(item);
}
</pre>

      <p>This desugars to something similar to this:</p>

      <pre>
<h-k>let mut</h-k> iter = <h-t>IntoIterator</h-t>::into_iter(iter);
<h-k>loop</h-k> {
    <h-k>match</h-k> <h-t>Iterator</h-t>::next(&amp;<h-k>mut</h-k> iter) {
        <h-t>Some</h-t>(item) =&gt; {
            frombulate(item);
        }
        <h-t>None</h-t> =&gt; <h-k>break</h-k>;
    }
}
</pre>

      <p>
        Note that the code before which seemingly relied on nothing from the
        standard library suddenly uses the traits <code>IntoIterator</code> and
        <code>Iterator</code> and the enum <code>Option</code>, all of which are
        defined in the standard library.
      </p>

      <p>
        So what can we do about that? Simply forgo that kind of syntax sugar all
        together, and force the user to write loops that manually break when
        asked to?
      </p>

      <p>
        As I see it, there are two really viable solutions: macros and lang
        items. Macros, depending on their meaning and semantics, let you do
        anything from simple token replacement to embedding new syntaxes and
        modifying the language entirely. A powerful enough macro system lets the
        compiler stay unchanging while all syntac transformations are
        implemented in the standard library (or similar) itself; our looping
        could just become something like this:
      </p>

      <pre>
<h-k>macro</h-k> (<h-k>for</h-k> $item: <h-t>pat</h-t> <h-k>in</h-k> $iter: <h-t>expr</h-t> { $stmts: <h-t>stmt</h-t>* }) {
    <h-k>let mut</h-k> iter = <h-t>IntoIterator</h-t>::into_iter($iter);
    <h-k>loop</h-k> {
        <h-k>match</h-k> <h-t>Iterator</h-t>::next(&amp;<h-k>mut</h-k> iter) {
            <h-t>Some</h-t>($item) =&gt; {Â $stmts }
            <h-t>None</h-t> =&gt; <h-k>break</h-k>;
        }
    }
}
</pre>

      <p>
        ... which could let it be documented like any other item, follow lexical
        scoping rules, be versionable, and so on. 
      </p>

      <p>
        This does solve quite a lot of the issues, but creates some more. If the
        macro system is powerful enough to introduce new statement forms without
        issue (like above), then suddenly name resolution and parsing start
        becoming quite entangled which can complicate the compiler, worsen error
        messages, and make tools like language servers and formatters harder to
        write robustly.
      </p>

      <p>
        The other approach mentioned is that of  
        <a href="https://doc.rust-lang.org/unstable-book/language-features/lang-items.html">
          lang items</a>.
        Though I'm sure this is a technique employed by languages other than
        Rust, that's where I've seen the term first used. The core idea behind
        this is to annotate certain items with a special marker, which lets the
        compiler refer to those items indirectly via that marker. From the
        <a href="https://github.com/rust-lang/rust/blob/master/library/core/src/iter/traits/collect.rs#L231-L262">
          Rust standard library</a>:
      </p>
      
      <pre>
<h-k>pub trait</h-k> <h-t>IntoIterator</h-t> {
    <h-k>type</h-k> <h-t>Item</h-t>;
    <h-k>type</h-k> <h-t>IntoIter</h-t>: <h-t>Iterator</h-t>&lt;<h-t>Item</h-t> = <h-t>Self</h-t>::<h-t>Item</h-t>&gt;;
    
    #[lang = <h-l>"into_iter"</h-l>]
    <h-k>fn</h-k> into_iter(self) -&gt; <h-t>Self:</h-t>:<h-t>IntoIter</h-t>;
}
</pre>

      <p>
        When desugaring, the compiler can just refer to that lang item and later
        resolve which it actually points to. In the desugaring example above,
        the &ldquo;truth&rdquo; is that the items <code>Iterator::next</code>,
        <code>Some</code> and so on are referred to by lang items in order to
        prevent weird bugs due to shadowing. 
      </p>

      <p>
        One thing to notice is that lang items effectively create a new
        namespace through which items can be resolved, but one with a lot less
        room for contextual ambiguity than the normal lexical scope.
      </p>

      <p>
        One thing we might want to do then is introduce a simple kind of
        shadowing to these lang items. If we keep the requirement that they are
        nameable globally without having to import anything, then we can't
        really use any kind of lexical scoping. Instead, if we also rely on a
        acyclic dependency graph, we could introduce a kind of inter-package
        shadowing. Consider a dependency graph like this, where the arrows
        indicates a dependency:
      </p>

      <pre>
         +---------+
         | one-app |
         +---------+
          |    |  |
          v    |  v
   +-------+   | +--------+
   | async |   | | errors |
   +-------+   | +--------+
    |     |    |  | 
    |     +--+ |  |
    |        | |  |
    v        v v  v
+---------+ +------+
| fast-io | | stdl |
+---------+ +------+
</pre>

      <p>
        If, say <code>stdl</code> declares a bunch of lang items, then those are
        visible to <code>async</code>, <code>errors</code> and
        <code>one-app</code>, since all of those depend on <code>stdl</code>,
        directly or indirectly.
      </p>

      <p>
        Further, if we stick to a simple rule that a lang item may be declared
        at most once in a package, that let's us redeclare it in another
        package. This leads to a question &ndash; if we depend on two packages
        that both declare a lang item, then which do we pick?
      </p>

      <p>
        If <code>async</code> redeclares a lang item declared in
        <code>stdl</code>, then we can probably safely say we should pick the
        &ldquo;top-most&rdquo; one (i.e. the one in <code>async</code>).
      </p>

      <p>
        What if <code>errors</code> uses code that relies on that lang item?
        Does it use the one declared in <code>async</code> or in
        <code>stdl</code>? 
      </p>

      <!-- notes -------------------------------------------------------------->

      <footer>
        <h2 id="notes">Notes</h2>

        <ol>
          <li id="note-1">
            <a href="#ref-1a">^</a> Why? Although you could argue doing this
            makes it easier to support embedded systems and weirder systems (by
            letting the users provide their own standard libraries specifically
            suited for those purposes), it's mostly just because I found it a
            fun challenge.
          </li>
        </ol>
      </footer>
    </article>
  </body>
</html>
